# GraphQL Schema and Resolvers

The **GraphQL Schema and Resolvers** serve as the backbone of the backend API, enabling clients to query and mutate data relating to databases, storage units, authentication, AI integrations, and settings. This layer defines how GraphQL operations map to core business logic and database interactions, bridging frontend requests with backend data processing.

---

## Table of Contents

- [Overview](#overview)
- [GraphQL Schema](#graphql-schema)
- [Resolvers](#resolvers)
  - [Queries](#queries)
  - [Mutations](#mutations)
- [Integration with Core Engine and Plugins](#integration-with-core-engine-and-plugins)
- [Authentication & Authorization](#authentication--authorization)
- [Example: Login Mutation](#example-login-mutation)
- [Mermaid Diagram: GraphQL Request Flow](#mermaid-diagram-graphql-request-flow)

---

## Overview

The GraphQL Schema provides a typed interface describing the queries and mutations supported by the system, alongside data types and input structures. The resolvers implement the handling of these GraphQL operations, making calls to the core engine, plugins, authentication middleware, and settings management modules.

This architecture enables:

- Dynamic querying of databases, schemas, and storage units
- Data retrieval with filtering and pagination
- Execution of raw SQL queries
- Construction and visualization of database graphs
- Authentication via credentials or saved profiles
- Settings management including metrics configuration
- Integration with AI providers for chat and model information

---

## GraphQL Schema

The schema defines the following key components:

- **Enums** for database types and relationship types
- **Input types** for login credentials, where conditions, records, and chat inputs
- **Objects** for rows results, storage units, graphs, AI chat messages, and settings
- **Root `Query`** for fetching versions, profiles, databases, schemas, data rows, graphs, AI providers, and models
- **Root `Mutation`** for login, logout, settings updates, and CRUD operations on storage units and rows

Example partial schema snippet:

```graphql
enum DatabaseType {
  Postgres
  MySQL
  Sqlite3
  MongoDB
  Redis
  ElasticSearch
  MariaDB
  ClickHouse
}

type Query {
  Version: String!
  Profiles: [LoginProfile!]!
  Database(type: String!): [String!]!
  Schema: [String!]!
  
  StorageUnit(schema: String!): [StorageUnit!]!
  Row(schema: String!, storageUnit: String!, where: WhereCondition, pageSize: Int!, pageOffset: Int!): RowsResult!
  RawExecute(query: String!): RowsResult!
  Graph(schema: String!): [GraphUnit!]!

  AIProviders: [AIProvider!]!
  AIModel(providerId: String, modelType: String!, token: String): [String!]!
  AIChat(providerId: String, modelType: String!, token: String, schema: String!, input: ChatInput!): [AIChatMessage!]!
  SettingsConfig: SettingsConfig!
}

input LoginCredentials {
  Id: String
  Type: String!
  Hostname: String!
  Username: String!
  Password: String!
  Database: String!
  Advanced: [RecordInput!]
}

input LoginProfileInput {
  Id: String!
  Type: DatabaseType!
  Database: String
}

# ... more definitions ...

``` 

---

## Resolvers

Resolvers define the methods that handle each GraphQL operation. They are typically generated by `gqlgen` and implemented in Go, connecting the schema definitions to the underlying core engine and business logic.

### Queries

Common query resolvers include:

- `Version`: Returns application or image version
- `Profiles`: Retrieves configured login profiles
- `Database`: Fetches available databases for a specified type
- `Schema`: Lists schemas available under current credentials
- `StorageUnit`: Gets storage units (e.g., tables/collections) for a schema
- `Row`: Fetches rows of data with filters, pagination, and sorting
- `RawExecute`: Allows arbitrary SQL command execution
- `Graph`: Returns graphical relationships among storage units
- `AIProviders` / `AIModel` / `AIChat`: Provide AI service integration
- `SettingsConfig`: Gets current app settings

### Mutations

Common mutation resolvers include:

- `Login`: Authenticate using direct credentials
- `LoginWithProfile`: Authenticate using stored profile
- `Logout`: End user session
- `UpdateSettings`: Update application settings such as metrics enabling
- `AddStorageUnit`, `UpdateStorageUnit`: Manage schema/table definitions
- `AddRow`, `DeleteRow`: Insert or remove records in storage units

---

## Integration with Core Engine and Plugins

Resolvers interact closely with:

- **Core Engine**: Uses `src.MainEngine.Choose` to select appropriate database plugin based on type.
- **Plugins**: Handles database-specific operations (e.g., Postgres, MySQL plugins).
- **Authentication**: Uses middleware and auth package functions for credential retrieval and session management.
- **Settings**: Reads and modifies settings via the `settings` package.
- **AI Modules**: Interfaces with LLM clients for AI chat and model data.

These dependencies work together to realize GraphQL API functionality by translating GraphQL operations into meaningful backend processes.

---

## Authentication & Authorization

The authentication system ensures:

- Public routes and introspection queries are allowed without tokens.
- Token validation is performed for protected routes.
- Credentials are fetched from context for plugin operations.

The `auth` package provides middleware that verifies tokens and injects credentials into the request context for resolvers to use.

---

## Example: Login Mutation

Here is a simplified example of the login mutation resolver implemented in Go:

```go
func (m *mutationResolver) Login(ctx context.Context, credentials model.LoginCredentials) (*model.StatusResponse, error) {
  // Use auth package to verify and set login cookie
  status, err := auth.Login(ctx, &credentials)
  if err != nil {
    return nil, err
  }
  return status, nil
}
```

This mutation accepts login credentials, calls the login logic which sets an HTTP cookie, and returns a status response indicating success or failure.

---

## Mermaid Diagram: GraphQL Request Flow

This diagram illustrates the flow of a GraphQL API request through the system from the HTTP layer to the resolver and core engine.

```mermaid
flowchart TD
  A[Client] --> B[GraphQL HTTP Handler]
  B --> C{Authenticated?}
  C -- No --> D[Return Error]
  C -- Yes --> E[Context with Credentials]
  E --> F[Resolver]
  F --> G[Select DB Plugin (Core Engine)]
  G --> H[Invoke Plugin Operation]
  H --> I[Database]
  I --> J[Data & Metadata]
  J --> K[Resolver]
  K --> L[GraphQL Response]
  L --> A
```

---

## Source Links

For more details, refer to the following source files:

- [GraphQL Schema Definitions](core/graph/schema.graphqls)
- [GraphQL Resolvers Implementation](core/graph/schema.resolvers.go)
- [Authentication Logic](core/src/auth/auth.go)
- [Core Engine and Plugins](core/src/src.go)
- [Graph HTTP Handlers](core/graph/http.resolvers.go)

---

This GraphQL layer is crucial for exposing a flexible and extensible API, allowing clients to interact with complex database structures and AI integrations while maintaining security and modularity through plugins and resolvers.